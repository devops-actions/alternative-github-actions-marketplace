name: Deploy Frontend

concurrency:
  group: azure-deployment-${{ vars.AZURE_RESOURCE_GROUP }}
  cancel-in-progress: false

on:
  workflow_dispatch:

env:
  AZURE_CORE_ONLY_SHOW_ERRORS: true
  AZURE_CORE_ERROR_RECOMMENDATION: false
  AZURE_CORE_COLLECT_TELEMETRY: false
  AZURE_LOGGING_ENABLE_LOG_FILE: false
  AZURE_CORE_SURVEY_MESSAGE: false
  AZURE_AUTO_UPGRADE_ENABLE: false
  AZURE_CORE_NO_COLOR: true
  AZURE_EXTENSION_USE_DYNAMIC_INSTALL: false

permissions:
  contents: read
  id-token: write

jobs:
  build-and-deploy:
    name: Build and Deploy Frontend
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.1

      - name: Log in to Azure (OIDC)
        uses: azure/login@v2.3.0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Resolve Static Web App name and suffix
        run: |
          swaName=$(az staticwebapp list \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --query "[0].name" -o tsv)

          if [ -z "$swaName" ]; then
            echo "::error::No static web app found in resource group ${{ vars.AZURE_RESOURCE_GROUP }}"
            exit 1
          fi

          swaHost=$(az staticwebapp show \
            --name "$swaName" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --query "defaultHostname" -o tsv)

          if [ -z "$swaHost" ]; then
            echo "::error::Failed to resolve Static Web App hostname for $swaName"
            exit 1
          fi

          suffix=${swaName#swa-}
          echo "SWA_NAME=$swaName" >> $GITHUB_ENV
          echo "SWA_HOST=$swaHost" >> $GITHUB_ENV
          echo "SWA_SUFFIX=$suffix" >> $GITHUB_ENV
          echo "FRONTEND_BASE_URL=https://$swaHost" >> $GITHUB_ENV

      - name: Resolve Function App host
        run: |
          funcName=$(az functionapp list \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --query "sort_by([?contains(kind, 'functionapp')], &name)[0].name" -o tsv)

          if [ -z "$funcName" ]; then
            echo "::error::No function app found in resource group ${{ vars.AZURE_RESOURCE_GROUP }}"
            exit 1
          fi

          funcHost=$(az functionapp show \
            --name "$funcName" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --query "defaultHostName" -o tsv)

          if [ -z "$funcHost" ]; then
            echo "::error::Failed to resolve Function App hostname for $funcName"
            exit 1
          fi
          echo "FUNCTION_APP_NAME=$funcName" >> $GITHUB_ENV
          echo "FUNCTION_APP_HOST=$funcHost" >> $GITHUB_ENV
          echo "API_BASE_URL=https://$funcHost/api" >> $GITHUB_ENV

      - name: Resolve App Insights connection string
        id: appinsights
        run: |
          suffix="$SWA_SUFFIX"
          if [ -z "$suffix" ]; then
            echo "::error::Missing Static Web App suffix; cannot resolve App Insights name"
            exit 1
          fi

          appiName="appi-$suffix"
          connection=$(az resource show \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --resource-type "microsoft.insights/components" \
            --name "$appiName" \
            --query "properties.ConnectionString" -o tsv)

          if [ -z "$connection" ]; then
            # Fallback to first component in case naming diverged
            connection=$(az resource list \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --resource-type "microsoft.insights/components" \
              --query "[0].properties.ConnectionString" -o tsv)
          fi
          if [ -z "$connection" ]; then
            echo "::error::No Application Insights resource found in RG ${{ vars.AZURE_RESOURCE_GROUP }}"
            exit 1
          fi
          echo "connection_string=$connection" >> $GITHUB_OUTPUT

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci
        working-directory: src/frontend

      - name: Build frontend
        run: |
          VITE_API_BASE_URL="$API_BASE_URL" \
          VITE_APPINSIGHTS_CONNECTION_STRING="${{ steps.appinsights.outputs.connection_string }}" \
          VITE_PLAUSIBLE_TRACKING_DOMAIN="${{ vars.PLAUSIBLE_TRACKING_DOMAIN }}" \
          npm run build
        working-directory: src/frontend

      - name: Get Static Web App deployment token
        id: swa-token
        run: |
          swaName="$SWA_NAME"
          if [ -z "$swaName" ]; then
            echo "::error::No static web app name available"
            exit 1
          fi
          token=$(az staticwebapp secrets list --name "$swaName" --query "properties.apiKey" -o tsv)
          echo "::add-mask::$token"
          echo "deployment_token=$token" >> $GITHUB_OUTPUT

      - name: Copy staticwebapp.config.json into dist
        run: |
          cp src/frontend/staticwebapp.config.json src/frontend/dist/

      - name: Deploy to Azure Static Web Apps (prebuilt dist)
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ steps.swa-token.outputs.deployment_token }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: 'upload'
          app_location: 'src/frontend/dist'
          skip_app_build: true
          skip_api_build: true

      - name: Wait for SWA + assets to be ready
        run: |
          set -e
          echo "Checking $FRONTEND_BASE_URL"
          for i in $(seq 1 30); do
            echo "Attempt $i/30"
            html=$(curl -fsSL "$FRONTEND_BASE_URL" || true)
            if printf '%s' "$html" | grep -q "<title>Alternative GitHub Actions Marketplace</title>"; then
              asset=$(printf '%s' "$html" | grep -oE '/assets/index-[^"\x27]+\.js' | head -n 1 || true)
              if [ -n "$asset" ]; then
                curl -fsSI "$FRONTEND_BASE_URL$asset" >/dev/null && echo "SWA assets ready: $asset" && break
              fi
            fi
            sleep 5
          done

      - name: Pre-warm API endpoints
        run: |
          set -e
          echo "Warming up API at $API_BASE_URL"

          # Prefer warming up the small stats payload rather than repeatedly downloading the full list.
          for i in $(seq 1 60); do
            echo "Attempt $i/60"
            code=$(curl -sS -o /tmp/actions-stats.json -w "%{http_code}" \
              --connect-timeout 5 --max-time 30 \
              "$API_BASE_URL/actions/stats" || true)
            if [ "$code" = "200" ]; then
              # Basic sanity check: response looks like JSON and contains a total field.
              if head -c 200 /tmp/actions-stats.json | grep -q '"total"'; then
                echo "API stats ready"
                break
              fi
              echo "Stats returned 200 but did not include expected payload yet"
            else
              echo "Stats not ready yet (http=$code)"
            fi
            sleep 5
          done

      - name: Temporarily allow GitHub runner IP (for E2E tests)
        run: |
          set -e
          runnerIp=$(curl -s https://api.ipify.org)
          if [ -z "$runnerIp" ]; then
            echo "::error::Failed to determine runner public IP"
            exit 1
          fi

          echo "Runner public IP: $runnerIp"

          ruleName="AllowGitHubRunnerE2E-${GITHUB_RUN_ID}"
          echo "ALLOW_RULE_NAME=$ruleName" >> $GITHUB_ENV

          az functionapp config access-restriction add \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --name "$FUNCTION_APP_NAME" \
            --rule-name "$ruleName" \
            --action Allow \
            --ip-address "$runnerIp/32" \
            --priority 88 \
            --description "Temporary allow for GitHub Actions E2E tests"

          sleep 10
          echo "RUNNER_PUBLIC_IP=$runnerIp" >> $GITHUB_ENV

      - name: Diagnose API access + CORS (runner + browser origin)
        run: |
          set -euo pipefail
          echo "FRONTEND_BASE_URL=$FRONTEND_BASE_URL"
          echo "API_BASE_URL=$API_BASE_URL"
          echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME"

          echo "--- Function App CORS config (platform) ---"
          az functionapp cors show \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --name "$FUNCTION_APP_NAME" || true

          echo "--- App setting CORS_ALLOWED_ORIGINS (if set) ---"
          az functionapp config appsettings list \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --name "$FUNCTION_APP_NAME" \
            --query "[?name=='CORS_ALLOWED_ORIGINS' || name=='CORS_ALLOW_ORIGINS'].{name:name,value:value}" -o table || true

          echo "--- GET /actions/list with Origin header ---"
          getCode=$(curl -sS -D /tmp/actions-list.headers -o /tmp/actions-list.json -w "%{http_code}" \
            -H "Origin: $FRONTEND_BASE_URL" \
            "$API_BASE_URL/actions/list" || true)
          sed -n '1,25p' /tmp/actions-list.headers || true
          if [ "$getCode" != "200" ]; then
            echo "::error::GET /actions/list failed (http=$getCode)"
            exit 1
          fi
          head -c 200 /tmp/actions-list.json || true
          echo

          echo "--- OPTIONS preflight /actions/list ---"
          optCode=$(curl -sS -D /tmp/actions-list.options.headers -o /dev/null -w "%{http_code}" -X OPTIONS \
            -H "Origin: $FRONTEND_BASE_URL" \
            -H "Access-Control-Request-Method: GET" \
            -H "Access-Control-Request-Headers: content-type" \
            "$API_BASE_URL/actions/list" || true)
          sed -n '1,25p' /tmp/actions-list.options.headers || true
          if [ "$optCode" != "204" ]; then
            echo "::error::OPTIONS preflight for /actions/list failed (http=$optCode). Browser requests may fail due to CORS preflight."
            exit 1
          fi

          echo
          echo "--- GET /actions/stats with Origin header ---"
          statsCode=$(curl -sS -D /tmp/actions-stats.headers -o /tmp/actions-stats.json -w "%{http_code}" \
            -H "Origin: $FRONTEND_BASE_URL" \
            "$API_BASE_URL/actions/stats" || true)
          sed -n '1,25p' /tmp/actions-stats.headers || true
          if [ "$statsCode" != "200" ]; then
            echo "::error::GET /actions/stats failed (http=$statsCode)"
            exit 1
          fi
          head -c 200 /tmp/actions-stats.json || true

          echo
          echo "--- OPTIONS preflight /actions/stats ---"
          statsOptCode=$(curl -sS -D /tmp/actions-stats.options.headers -o /dev/null -w "%{http_code}" -X OPTIONS \
            -H "Origin: $FRONTEND_BASE_URL" \
            -H "Access-Control-Request-Method: GET" \
            -H "Access-Control-Request-Headers: content-type" \
            "$API_BASE_URL/actions/stats" || true)
          sed -n '1,25p' /tmp/actions-stats.options.headers || true
          if [ "$statsOptCode" != "204" ]; then
            echo "::error::OPTIONS preflight for /actions/stats failed (http=$statsOptCode). Browser requests may fail due to CORS preflight."
            exit 1
          fi

      - name: Install Playwright browsers
        run: npx playwright install --with-deps
        working-directory: src/frontend

      - name: Run E2E tests against deployed site
        working-directory: src/frontend
        env:
          PLAYWRIGHT_WORKERS: 12
        run: npm run test:e2e

      - name: Remove temporary GitHub runner allow rule
        if: always()
        run: |
          set +e
          az functionapp config access-restriction remove \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --name "$FUNCTION_APP_NAME" \
            --rule-name "$ALLOW_RULE_NAME"
          exit 0

      - name: Upload Playwright report (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: |
            src/frontend/playwright-report
            src/frontend/test-results
          if-no-files-found: ignore
